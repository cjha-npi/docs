

// #region ⚠️ WARNING: DO NOT CREATE CUSTOM HASH/HREF
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 
// TL;DR: In edge cases a custom hash can make the default
// side nav disappear.
// 
// Doxygen uses NAVTREEINDEX to look up a hash/href. The
// NAVTREEINDEX is divided into multiple files and contains
// root + hash (root being the page i.e. ending with html).
// For any hash/href it looks up in NAVTREEINDEX for the
// root + hash combo and if it doesn't find that combo then
// it selects the root. This logic works fine with Doxygen's
// own hash, but with custom hash, sometimes it is unable to
// find the root because while looking it moved to another
// file (since NAVTREEINDEX is divided into multiple files)
// which does not have the root as well. When this happens
// Doxygen selects the index.html i.e. "Main Project" item
// as the fallback. 
// 
// The selection of "Main Project" as fallback is a problem
// for us. By default 'Main Project" is expanded (even if the)
// starting page is index.html. Since, Doxygen only loads the
// child items in side nav when an item is expanded, by default
// the child of "Main Project" is available. In our sideNavTweak()
// function we take advantage of this fact and promote all child
// of "Main Project" to the top level and remove the "Main Project"
// item itself ("Main Project" can still be reached by main nav in
// the header). When the fallback happens due to Doxygen unable to
// find the hash and the root, in that case it selects "Main Project"
// item in side nav but does not expand it and since we remove it
// in sideNavTweak(), the default side nav becomes empty and cannot
// be navigated.
// 
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// #endregion

// #region ⚠️ WARNING: PAGE-NAV IN MOBILE VIEW
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
// When using a touch screen/mobile view width desktop mode, when we resize the side
// nav the page width shrinks. This is not being done by doxy-plus or Doxygen Awesome
// theme, but rather this is done directly by Doxygen. I have tested it multiple times.
// 
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// #endregion


// @ts-nocheck - needed, otherwise Visual Studio code 
// complains that 'store' is not found.

; (function ($) {
  'use strict';

  // #region 🟩 CONSTANTS
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  // Key to store the last date when the expired data was purged.
  // This key is origin-specific (i.e. not project specific) and
  // is stored directly in local-storage without the help of store.js
  const KEY__EXPIRED_DATA_PURGE_DATE = 'expired_data_purge_date';

  // Project specific keys. These keys are stored in the local
  // storage using a namespace through store.js add on. This
  // provides separate namespace per-project at the same origin.
  const KEY__PREV_URL = 'prev_url'; // URL to restore on startup
  const KEY__DUAL_NAV = 'dual_nav'; // Dual-nav enabled/disabled state
  const KEY__SHOW_PAGE_NAV = 'show_page_nav'; // Page Nav state
  const KEY__SHOW_LEAF_PANE = 'show_leaf_pane'; // Leaf Pane state when available
  const KEY__AUTO_HIDE_LISTS = 'auto_hide_lists'; // Auto hiding of leaf pane and page nav based on window width
  const KEY__ROOT_PANE_WIDTH = 'root_pane_width'; // Root Pane width
  const KEY__LEAF_PANE_WIDTH = 'leaf_pane_width'; // Leaf Pane width
  const KEY__GEN_DATA = 'gen_data'; // Doxygen generation metadata
  const KEY__HTML_PAGES = 'html_pages'; // Key to store _htmlPages array
  const KEY__HTML_PAGES_TREE_INDENTED = 'html_pages_tree_indented'; // Boolean flag for indentation of of tree generated by _htmlPages
  const KEY__HTML_PAGES_TREE_EXPANDED_NODES = 'html_pages_tree_expanded_nodes'; // Array of expanded node IDs in tree generated from _htmlPages

  // Constants
  const MIN_W = 100; // Minimum width (px) of panes
  const GUTTER_W = 250; // Gutter width (px) on right side in dual-nav
  const TIME_TO_LIVE = 30 * 24 * 60 * 60 * 1000; // Time (ms) until stored data is considered stale (30 days). 7 * 24 * 60 * 60 * 1000 == 7 Days, 30 * 24 * 60 * 60 * 1000 == 30 Days
  const IS_HTML_END = /\.(?:xhtml|html)$/i; // Regex to test for strings ending in .xhtml or .html (case-insensitive)
  const TIMEOUT_MS = 2000; // Timeout duration (ms) when waiting for a DOM element

  const DOC_ROOT = (() => {
    // Determine the base path (DOC_ROOT) of the current documentation site.
    // This is useful for loading assets (e.g., CSS/JS) relative to the script location,
    // even when the script is located in a nested folder or executed in varied contexts.
    // ⚠️ NOTE: This is a IIFE (Immediately Invoked Function Expression) and it runs immediately
    // at defination time and the resulting string is stored in DOC_ROOT. Every time DOC_ROOT
    // is referenced afterward, it is getting that cached value, not re-running the function.

    // Helper function: Extracts the folder path from a full URL.
    // Example: "https://example.com/docs/js/script.js" -> "https://example.com/docs/js/"
    // Example: "file:///F:/Doxy/Z_Test/Test_5/html/script.js" -> "file:///F:/Doxy/Z_Test/Test_5/html/"
    const getDir = src => src.slice(0, src.lastIndexOf('/') + 1);
    // Primary method: Use 'document.currentScript' to get the <script> element currently executing.
    // This is the most accurate and modern way to locate the script's own path.
    const self = document.currentScript;
    if (self && self.src) {
      let dir = getDir(self.src); // The folder path of the script itself.
      return dir;
    }

    // Fallback: If 'currentScript' is unavailable (e.g., in older browsers or dynamic environments),
    // try to locate a known Doxygen-generated script like 'navtreedata.js'.
    // This file typically resides in the root documentation folder.
    const tree = document.querySelector('script[src$="navtreedata.js"]');
    if (tree && tree.src) {
      let dir = getDir(tree.src); // The folder path where 'navtreedata.js' is located.
      console.warn(`Root: ${dir} (Determined by navtreedata.js file)`);
      return dir;
    }

    // Final fallback: If both methods fail, fall back to the root of the current origin.
    // Example: If on "https://example.com/docs/page.html", this gives "https://example.com/"
    // ⚠️ NOTE: This will result in "file://" when opened directly from folder
    const dir = window.location.origin + '/';
    console.error(`Root: ${dir} (Ultimate Fallback)`);
    return dir;
  })();

  const HTML_NAME = (() => {
    // just HTML name of current page e.g bar.com/proj/class_foo.html#abc -> class_foo
    // this name is used to store secondary pane's collapsed nodes
    return window.location.pathname.split('/').pop().toLowerCase().replace(/\..*$/, '');
  })();

  const PROJ_NAMESPACE = (() => {
    // project's namespace, this is almost same as DOC_ROOT except it is formatted to serve as a namespace string

    // 1) Strip any trailing slashes
    let raw = DOC_ROOT.replace(/\/+$/, '');

    // 2) Remove protocol (e.g. “https://” or “file:///”)
    raw = raw.replace(/^[a-z]+:\/\//i, '');

    // 3) Drop any credentials before an “@”
    raw = raw.replace(/^[^\/@]+@/, '');

    // 4) Remove query string or fragment
    raw = raw.split(/[?#]/, 1)[0];

    // 5) For Windows drives, drop the colon after the letter (e.g. “F:” → “F”)
    raw = raw.replace(/^([A-Za-z]):/, '$1');

    // 6) Split on both “/” and “\”, filter out empty segments
    const parts = raw.split(/[\/\\]+/).filter(Boolean);

    // 7) Slugify each segment (allow only A–Z, a–z, 0–9, underscore, dash)
    const slugged = parts.map(seg =>
      seg
        .replace(/[^A-Za-z0-9_-]+/g, '-')  // invalid → “-”
        .replace(/-+/g, '-')               // collapse multiple “-”
        .replace(/^-+|-+$/g, '')           // trim leading/trailing “-”
    );

    // 8) Join with dash and return
    return slugged.join('-');
  })();

  const STORAGE = store.namespace(PROJ_NAMESPACE); // here "store" is a function from store.js, creating our own namespace

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 CONSTANTS

  // #region 🟩 GLOBAL VARIABLES
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  let _dualNav = load(KEY__DUAL_NAV, true);
  let _showPageNav = load(KEY__SHOW_PAGE_NAV, true);
  let _showLeafPane = load(KEY__SHOW_LEAF_PANE, true);
  let _autoHideLists = load(KEY__AUTO_HIDE_LISTS, true);
  let _rootPaneWidth = loadNum(KEY__ROOT_PANE_WIDTH, 200);
  let _leafPaneWidth = loadNum(KEY__LEAF_PANE_WIDTH, 400);

  // Save initial settings to refresh their expiration timers
  save(KEY__DUAL_NAV, _dualNav);
  save(KEY__SHOW_PAGE_NAV, _showPageNav);
  save(KEY__SHOW_LEAF_PANE, _showLeafPane);
  save(KEY__AUTO_HIDE_LISTS, _autoHideLists);
  save(KEY__ROOT_PANE_WIDTH, _rootPaneWidth);
  save(KEY__LEAF_PANE_WIDTH, _leafPaneWidth);

  // Array containing the html pages in this project.
  const _htmlpages = [];

  // Array containing the default Doxygen hash/href links for
  // the current page. ⚠️ NOTE: The parent nodes in this
  // array contains the special 'dp-' links generated by
  // doxy-plus and not the href. We cannot create custom
  // href because of issues with how Doxygen searches for
  // href. For detailed description read the WARNING at the
  // top of this page.
  const _pageLinks = [];

  const _sectionMap = new Map();
  const _htmlPagesExpandedNodes = new Set(); // ids of expanded nodes in _htmlpages
  const _pageLinksCollapsedNodes = new Set(); // ids of collapsed nodes in _pageLinks

  let _consoleObjectName = ''; // Name of the global console object for invoking functions
  let _pageLinksRemark = ''; // Remarks or notes from page links tree generation
  let _htmlpagesIndented = false; // Whether the _htmlpages tree is indented

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 GLOBAL VARIABLES

  // #region 🟩 HELPERS
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  function save(key, val) {
    // saves the data using store.js
    STORAGE.set(key, val, Date.now() + TIME_TO_LIVE);
  }

  // For a value `val = undefined`
  // `val == null` is true but `val === null` is false
  // `val != null` is false but `val !== null` is true

  function load(key, defVal = null) {
    // loads the data store.js
    // returns undefined (which is slightly different than null) if the key does not exist or is expired
    const v = STORAGE.get(key);
    return v === undefined ? defVal : v;
  }

  function loadNum(key, defVal = null) {
    // loads the data using store.js
    // returns undefined (which is slightly different than null) if the key does not exist or is expired
    const v = STORAGE.get(key);
    if (v == null) return defVal; // == treats null and undefined as same but === does not
    const n = Number(v);
    return isNaN(n) ? defVal : n;
  }

  function debounce(fn, ms = 50) {
    // Return a debounced version of fn:
    // fn will only be invoked after ms milliseconds have passed without a new call.
    // This is a way to “coalesce” a rapid burst of events into a single call after things have settled down.

    let debounceId, idleId, fallbackId;

    return (...args) => {
      // Cancel any pending debounce timer or idle callback before scheduling a new one
      clearTimeout(debounceId); // cancel the pending debounce
      if (idleId) cancelIdleCallback(idleId); // cancel any pending idle callback
      clearTimeout(fallbackId); // cancel any pending fallback timer

      // Schedule fn to run after the specified delay
      debounceId = setTimeout(() => {
        if ('requestIdleCallback' in window) {
          // If supported, run fn when the browser is idle (with a timeout)
          idleId = requestIdleCallback(() => fn(...args), { timeout: 200 });
        } else {
          // Otherwise, fallback to a zero-delay timeout
          fallbackId = setTimeout(() => fn(...args), 0); // fallback into a zero-delay timeout
        }
      }, ms);
    };
  }


  function waitFor(selector) {
    // Waits for the first element matching any CSS selector.
    // selector: Any valid querySelector string.
    // Returns: Promise<Element>
    return new Promise((resolve, reject) => {
      // Immediate hit?
      const el = document.querySelector(selector);
      if (el) {
        //console.log(`Selector "${selector}" found immediately, no need for mutation observer`);
        return resolve(el);
      }

      // pre-declare the timer variable for the closure
      let timer;

      // Otherwise observe mutations until we find one
      // In MutationObserver, first argument '_' is an
      // intentionally unused parameter, by using '_'
      // it means we are watching for any change. The
      // second argument 'observer' is the own 'obs'
      // instance.
      const obs = new MutationObserver((_, observer) => {
        const found = document.querySelector(selector);
        if (found) {
          //console.log(`Selector "${selector}" found in mutation observer, Task Complete!`);
          observer.disconnect();
          clearTimeout(timer);
          resolve(found);
        }
        //else{
        //  console.log(`Selector "${selector}" NOT found in mutation observer, Looking...`);
        //}
      });
      obs.observe(document.body, { childList: true, subtree: true });

      // Give up after timeout
      timer = setTimeout(() => {
        obs.disconnect();
        console.log(`Timed out waiting for selector "${selector}" after ${TIMEOUT_MS} ms`);
        resolve(null);
      }, TIMEOUT_MS);
    });
  }

  function printTreeTableFormat(tree) {
    // prints a tree in table format. each item in tree should have 3 entries: name, path, kids
    function flattenTree(oldTree, preName = '', newTree = []) {
      for (let ii = 0; ii < oldTree.length; ++ii) {
        const newName = preName === '' ? oldTree[ii][0] : preName + " → " + oldTree[ii][0];
        if (Array.isArray(oldTree[ii][2]) && oldTree[ii][2].length > 0) {
          newTree.push({ Name: newName, Link: oldTree[ii][1], Kids: oldTree[ii][2].length });
          flattenTree(oldTree[ii][2], newName, newTree);
        }
        else {
          newTree.push({ Name: newName, Link: oldTree[ii][1], Kids: null });
        }
      }
      return newTree;
    }
    console.table(flattenTree(tree));
  }

  function printTreeGroupFormat(tree) {
    // prints a tree in group format. each item in tree should have 3 entries: name, path, kids
    tree.forEach(([name, href, kids]) => {
      if (Array.isArray(kids)) {
        if (kids.length > 0) {
          console.group(`${name} → ${href} → Kids: ${kids.length}`);
          printTreeGroupFormat(kids);
          console.groupEnd();
        }
        else {
          console.log(`${name} → ${href} → Kids: 0`);
        }
      }
      else {
        console.log(`${name} → ${href} → ${kids}`);
      }
    });
  }

  function isTreeIndented(tree) {

    // Determine whether the tree should use indentation.
    // Assumes each entry in the tree has three parts: name, path and kids
    // Returns true if indentation is needed, false if it can be omitted.

    // Indentation means having extra padding for sub-levels. However,
    // when a tree has only two levels and each top-level item has
    // sub-items and those sub-items have no further children, the 
    // top-level entries display expand/collapse buttons while the 
    // sub-items do not, and so we don't need indentation, saving 
    // space and improving readability. Although both primary and 
    // secondary trees meet this criterion and can omit indentation, 
    // this function prevents accidentally removing indentation when it’s needed.

    // Empty or invalid tree: default to using indentation.
    if (!Array.isArray(tree) || tree.length === 0) {
      return true;
    }

    // Check each top-level entry in the tree.
    for (let ii = 0; ii < tree.length; ++ii) {
      const kids = tree[ii][2];

      if (Array.isArray(kids) && kids.length > 0) {
        // If any child has its own children, we need indentation.
        for (let jj = 0; jj < kids.length; ++jj) {
          if (kids[jj][2] != null) return true;
        }
        // Found a two-level branch with children but no grandchildren;
        // continue checking other branches.
      }
      else {
        // A top-level item without children means tree must be indented.
        return true;
      }
    }

    // All branches are exactly two levels deep with no grandchildren:
    // indentation can be safely omitted.
    return false;
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 HELPERS

  // #region 🟩 SEARCHBAR TWEAK
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  async function searchbarTweak() {

    // Tweaks the search bar’s selector text to reflect the current search context.
    // By default, the selector shows only a magnifying-glass icon; this function
    // replaces it with the appropriate text label.

    async function update() {
      // Sync the '--dp-search-field' CSS variable based on the current search category.

      const start = performance.now();
      // Wait for searchBox and indexSectionLabels to be available (timeout after TIMEOUT_MS).
      while (!window.searchBox || !window.indexSectionLabels) {
        const elapsed = performance.now() - start;
        if (elapsed > TIMEOUT_MS) {
          console.error(`Searchbar Tweak - Update: Timed out waiting for selector "window.searchBox" and/or "window.indexSectionLabels" after ${elapsed} ms`);
          return;
        }
        //console.log(`Searchbar Tweak - Update: Waiting for "window.searchBox" and/or "window.indexSectionLabels" after ${elapsed} ms...`);
        await new Promise(requestAnimationFrame);
      }

      // Determine label (fall back to 'All') and update CSS variable.
      const label = window.indexSectionLabels[window.searchBox.searchIndex] || 'All';
      document.documentElement.style.setProperty('--dp-search-field', `"${label}:"`);
      //console.log(`Searchbar Tweak - Update: SUCCESS "Search ${label}"`);
    }

    // Ensure window.searchBox.OnSelectItem exists before hooking into it.
    if (!window.searchBox || !window.searchBox.OnSelectItem) {
      const startTimeOnSelectItem = performance.now();
      while (!window.searchBox || !window.searchBox.OnSelectItem) {
        const elapsed = performance.now() - startTimeOnSelectItem;
        if (elapsed > TIMEOUT_MS) {
          console.error(`Searchbar Tweak: Timed out waiting for selector "window.searchBox" and/or "window.searchBox.OnSelectItem" after ${elapsed} ms`);
          break;
        }
        //console.log(`Searchbar Tweak: Waiting for "window.searchBox" and/or "window.searchBox.OnSelectItem" after ${elapsed} ms...`);
        await new Promise(requestAnimationFrame);
      }
    }

    // Override OnSelectItem to call update() whenever the user selects a different category from dropdown.
    if (window.searchBox && window.searchBox.OnSelectItem && typeof window.searchBox.OnSelectItem === 'function') {
      const orig = window.searchBox.OnSelectItem;
      window.searchBox.OnSelectItem = function (id) {
        const ret = orig.call(this, id);
        //console.log('Searchbar Tweak: Update On Select Item Triggered');
        update();
        return ret;
      };
      //console.log('Searchbar Tweak: SUCCESS');
    }
    else {
      console.error('Searchbar Tweak: Unable to set on search item change');
    }
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 SEARCHBAR TWEAK

  // #region 🟩 OPTIONS INIT
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  async function optionsInit() {

    if (document.getElementById('dp-opt-backdrop')) return;

    var backdrop = document.createElement('div');
    backdrop.id = 'dp-opt-backdrop';

    var modal = document.createElement('div');
    modal.id = 'dp-opt-modal';
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');

    var form = document.createElement('div');
    form.id = 'dp-opt-form';

    // Doxy-Plus Primary Nav checkbox
    var rowRoot = document.createElement('div');
    rowRoot.className = 'dp-opt-row';
    var lblRoot = document.createElement('label');
    lblRoot.className = 'dp-opt-label';
    var cbRoot = document.createElement('input');
    cbRoot.type = 'checkbox';
    cbRoot.id = 'dp-opt-cb-root';
    cbRoot.checked = _dualNav;
    lblRoot.appendChild(cbRoot);
    lblRoot.appendChild(document.createTextNode('Doxy-Plus Primary Nav'));
    rowRoot.appendChild(lblRoot);

    // Doxy-Plus Members List checkbox
    var rowLeaf = document.createElement('div');
    rowLeaf.className = 'dp-opt-row';
    var lblLeaf = document.createElement('label');
    lblLeaf.className = 'dp-opt-label';
    var cbLeaf = document.createElement('input');
    cbLeaf.type = 'checkbox';
    cbLeaf.id = 'dp-opt-cb-leaf';
    cbLeaf.checked = _showLeafPane;
    lblLeaf.appendChild(cbLeaf);
    lblLeaf.appendChild(document.createTextNode('Doxy-Plus Members List'));
    rowLeaf.appendChild(lblLeaf);

    // Page Nav checkbox
    var rowPage = document.createElement('div');
    rowPage.className = 'dp-opt-row';
    var lblPage = document.createElement('label');
    lblPage.className = 'dp-opt-label';
    var cbPage = document.createElement('input');
    cbPage.type = 'checkbox';
    cbPage.id = 'dp-opt-cb-page';
    cbPage.checked = _showPageNav;
    lblPage.appendChild(cbPage);
    lblPage.appendChild(document.createTextNode('Page Table of Contents'));
    rowPage.appendChild(lblPage);

    // Auto Hide checkbox
    var rowAuto = document.createElement('div');
    rowAuto.className = 'dp-opt-row';
    var lblAuto = document.createElement('label');
    lblAuto.className = 'dp-opt-label';
    var cbAuto = document.createElement('input');
    cbAuto.type = 'checkbox';
    cbAuto.id = 'dp-opt-cb-auto';
    cbAuto.checked = _autoHideLists;
    lblAuto.appendChild(cbAuto);
    lblAuto.appendChild(document.createTextNode('Auto Hide On-Page Lists'));
    rowAuto.appendChild(lblAuto);

    function setDoxyPlusCss() {
      if (_dualNav) {
        document.body.setAttribute('data-dp-dual-nav-active', '');
        cbLeaf.disabled = false;
        lblLeaf.classList.remove('dp-opt-disabled');
        if (_showLeafPane) document.body.setAttribute('data-dp-show-leaf-pane', '');
        else document.body.removeAttribute('data-dp-show-leaf-pane');
      }
      else {
        document.body.removeAttribute('data-dp-dual-nav-active');
        document.body.removeAttribute('data-dp-show-leaf-pane');
        cbLeaf.disabled = true;
        lblLeaf.classList.add('dp-opt-disabled');
      }
    }
    setDoxyPlusCss();

    function setPageNavCss() {
      if (_showPageNav) document.body.setAttribute('data-dp-show-page-nav', '');
      else document.body.removeAttribute('data-dp-show-page-nav');
    }
    setPageNavCss();

    function setAutoHideCss() {
      if (_autoHideLists) document.body.setAttribute('data-dp-auto-hide-lists', '');
      else document.body.removeAttribute('data-dp-auto-hide-lists');
    }
    setAutoHideCss();

    function onCbRootToggle() {
      _dualNav = cbRoot.checked;
      save(KEY__DUAL_NAV, _dualNav);
      setDoxyPlusCss();
      checkDualNavLayout();
    }
    cbRoot.addEventListener('change', onCbRootToggle);

    function onCbLeafToggle() {
      _showLeafPane = cbLeaf.checked;
      save(KEY__SHOW_LEAF_PANE, _showLeafPane);
      setDoxyPlusCss();
      checkDualNavLayout();
    }
    cbLeaf.addEventListener('change', onCbLeafToggle);

    function onCbPageToggle() {
      _showPageNav = cbPage.checked;
      save(KEY__SHOW_PAGE_NAV, _showPageNav);
      setPageNavCss();
    }
    cbPage.addEventListener('change', onCbPageToggle);

    function onCbAutoToggle() {
      _autoHideLists = cbAuto.checked;
      save(KEY__AUTO_HIDE_LISTS, _autoHideLists);
      setAutoHideCss();
    }
    cbAuto.addEventListener('change', onCbAutoToggle);

    // Assemble
    form.appendChild(rowRoot);
    form.appendChild(rowLeaf);
    form.appendChild(rowPage);
    form.appendChild(rowAuto);
    modal.appendChild(form);
    backdrop.appendChild(modal);
    document.body.appendChild(backdrop);

    // Modal open/close & positioning
    var lastFocus = null;

    function openModal() {
      var b = document.getElementById('dp-opt-backdrop');
      if (!b) return;

      document.body.classList.add('dp-opt-backdrop-blur');
      b.setAttribute('data-dp-opt-win-open', '');

      // default: centered
      modal.classList.remove('dp-opt-win-at-anchor');
      modal.style.left = '';
      modal.style.top = '';

      // Align right edge to #dp-options-btn if present
      var anchor = document.getElementById('dp-options-btn');
      if (anchor) {
        modal.classList.add('dp-opt-win-at-anchor');
        modal.style.left = '0px';
        modal.style.top = '0px';

        var btn = anchor.getBoundingClientRect();
        var mw = modal.offsetWidth;
        var mh = modal.offsetHeight;

        var desiredLeft = btn.right - mw;  /* align right edges */
        var desiredTop = btn.bottom + 8;   /* drop below a bit */

        var minLeft = 8;
        var maxLeft = Math.max(8, window.innerWidth - mw - 8);
        var minTop = 8;
        var maxTop = Math.max(8, window.innerHeight - mh - 8);

        var finalLeft = Math.min(Math.max(desiredLeft, minLeft), maxLeft);
        var finalTop = Math.min(Math.max(desiredTop, minTop), maxTop);

        modal.style.left = finalLeft + 'px';
        modal.style.top = finalTop + 'px';
      }

      lastFocus = document.activeElement;
      modal.setAttribute('tabindex', '-1');
      modal.focus();

      document.addEventListener('keydown', onKey);
      b.addEventListener('click', onBackdropClick);
    }

    function closeModal() {
      var b = document.getElementById('dp-opt-backdrop');
      if (!b) return;
      document.removeEventListener('keydown', onKey);
      b.removeEventListener('click', onBackdropClick);
      b.removeAttribute('data-dp-opt-win-open');
      document.body.classList.remove('dp-opt-backdrop-blur');
      if (lastFocus && typeof lastFocus.focus === 'function') lastFocus.focus();
    }

    function onBackdropClick(e) {
      if (e.target === backdrop) closeModal(); /* click-outside closes */
    }

    function onKey(e) {
      if (e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27) {
        e.preventDefault(); closeModal();
      } else if (e.key === 'Enter' || e.keyCode === 13) {
        e.preventDefault(); closeModal();
      }
    }

    const OPTIONS_SVG = (() => {

      const NS = "http://www.w3.org/2000/svg";

      function svgCreateLine(x1, y1, x2, y2, width) {
        const l = document.createElementNS(NS, "line");
        l.setAttribute("x1", x1);
        l.setAttribute("y1", y1);
        l.setAttribute("x2", x2);
        l.setAttribute("y2", y2);
        l.setAttribute("stroke-linecap", "round");
        l.setAttribute("stroke", "currentColor");
        l.setAttribute("stroke-width", width);
        l.setAttribute("vector-effect", "non-scaling-stroke");
        l.setAttribute("shape-rendering", "geometricPrecision");
        return l;
      }

      function svgCreateCircle(x, y, r) {
        const c = document.createElementNS(NS, "circle");
        c.setAttribute("cx", x);
        c.setAttribute("cy", y);
        c.setAttribute("r", r);
        c.setAttribute("fill", "currentColor");
        return c;
      }

      const y1 = '4';
      const y2 = '12';
      const y3 = '20';
      const w = '2';
      const r = '2.5';

      var svg = document.createElementNS(NS, "svg");
      svg.setAttribute("viewBox", "0 0 24 24");
      svg.setAttribute("aria-hidden", "true");
      svg.setAttribute("focusable", "false");

      svg.appendChild(svgCreateLine('2', y1, '3', y1, w));
      svg.appendChild(svgCreateLine('13', y1, '22', y1, w));
      svg.appendChild(svgCreateLine('2', y2, '11', y2, w));
      svg.appendChild(svgCreateLine('21', y2, '22', y2, w));
      svg.appendChild(svgCreateLine('2', y3, '3', y3, w));
      svg.appendChild(svgCreateLine('13', y3, '22', y3, w));

      svg.appendChild(svgCreateCircle('8', y1, r));
      svg.appendChild(svgCreateCircle('16', y2, r));
      svg.appendChild(svgCreateCircle('8', y3, r));

      return svg;
    })();

    // Make the options button
    const mo = new MutationObserver(setup);
    async function setup() {

      // Wait for the desktop search box container
      const itemSearchBox = await waitFor('#searchBoxPos2');
      if (!itemSearchBox) {
        console.error(`Options Button - Setup: '#searchBoxPos2' not found`);
        return;
      }

      mo.disconnect(); // prevent handling our own DOM changes

      // Only show toggle on desktop widths (>=768px)
      const winWidth = window.innerWidth || document.documentElement.clientWidth;
      if (winWidth >= 768) {

        // Try to find an existing toggle button
        let btn = itemSearchBox.querySelector('#dp-options-btn');
        if (btn) {
          // Move existing button to end of the search box and update its icon
          itemSearchBox.appendChild(btn);
          //console.log('Options Button - Setup: Reposition');
        }
        else {
          // Create a new toggle button and icon
          btn = document.createElement("button");
          btn.id = 'dp-options-btn';
          btn.type = "button";
          btn.setAttribute("aria-label", "Settings");
          btn.title = 'Show Options Window';
          btn.appendChild(OPTIONS_SVG);
          btn.addEventListener("click", openModal);
          itemSearchBox.appendChild(btn);
          //console.log('Options Button - Setup: New Button');
        }
      }
      //else {
      //  console.log('Options Button - Setup: Width < 768');
      //}

      // Observe the search box for childList changes (Doxygen rebuilds on resize)
      mo.observe(itemSearchBox, { childList: true });
    }
    setup();
    //console.log('Options Button: SUCCESS');
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 OPTIONS INIT

  // #region 🟩 DUAL NAV FUNCTIONS
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  function setRootPaneWidth(w) {
    if (w !== _rootPaneWidth) {
      _rootPaneWidth = w;
      save(KEY__ROOT_PANE_WIDTH, w);
      document.documentElement.style.setProperty('--dp-root-pane-width', `${w}px`);
    }
  }

  function setLeafPaneWidth(w) {
    if (w !== _leafPaneWidth) {
      _leafPaneWidth = w;
      save(KEY__LEAF_PANE_WIDTH, w);
      document.documentElement.style.setProperty('--dp-leaf-pane-width', `${w}px`);
    }
  }


  function checkDualNavLayout() {
    const wWin = window.innerWidth;
    if (!_dualNav || wWin < 768) return;
    const maxAllowed = wWin - GUTTER_W;
    if (_pageLinks.length > 0 && _showLeafPane && (!_autoHideLists || wWin > 1500)) {
      const total = _rootPaneWidth + _leafPaneWidth;
      if (total > maxAllowed) {
        const ratio = _rootPaneWidth / total;
        let nRoot = Math.floor(maxAllowed * ratio);
        let nLeaf = maxAllowed - nRoot;
        if (nRoot < MIN_W) nRoot = MIN_W;
        if (nLeaf < MIN_W) nLeaf = MIN_W;
        setRootPaneWidth(nRoot);
        setLeafPaneWidth(nLeaf);
      }
    }
    else {
      if (_rootPaneWidth > maxAllowed) {
        let nRoot = maxAllowed;
        if (nRoot < MIN_W) nRoot = MIN_W;
        setRootPaneWidth(nRoot);
      }
    }
  }

  function dualNavResizer(resizerId, getW) {

    // No specific resizer ID: wire both primary and secondary resizers
    if (!resizerId) {
      dualNavResizer('dp-root-pane-resizer', () => _rootPaneWidth);
      dualNavResizer('dp-leaf-pane-resizer', () => _leafPaneWidth);
      return;
    }

    // Calculate maximum combined width available for both panes
    const maxTotal = () => window.innerWidth - GUTTER_W;
    const resizer = document.getElementById(resizerId);
    let startX = 0, startW = 0, raf = null;

    // Handle pointer move: compute new width for the active pane
    function onMove(ev) {
      ev.preventDefault();
      if (raf) return;
      raf = requestAnimationFrame(() => {
        let newW = startW + (ev.clientX - startX);
        if (newW >= MIN_W) {
          if (resizerId === 'dp-leaf-pane-resizer') {
            if (_rootPaneWidth + newW <= maxTotal()) {
              setLeafPaneWidth(newW);
            }
          }
          else {
            if (_pageLinks.length > 0 && _showLeafPane && (!_autoHideLists || window.innerWidth > 1500)) {
              if (newW + _leafPaneWidth <= maxTotal()) {
                setRootPaneWidth(newW);
              }
            }
            else {
              if (newW <= maxTotal()) {
                setRootPaneWidth(newW);
              }
            }
          }
        }
        raf = null;
      });
    }

    // End drag: remove cursor style and listeners
    function onUp(evtUp) {
      evtUp.preventDefault();
      document.body.style.cursor = '';
      //resizer.releasePointerCapture(evtUp.pointerId);
      document.removeEventListener('pointermove', onMove);
      document.removeEventListener('pointerup', onUp);
      document.removeEventListener('pointercancel', onUp);
    }

    // Attach pointerdown to start drag-resize
    resizer.addEventListener('pointerdown', evtDown => {
      evtDown.preventDefault();
      //resizer.setPointerCapture(evtDown.pointerId);
      startX = evtDown.clientX;
      startW = getW();
      document.body.style.cursor = 'ew-resize';
      document.addEventListener('pointermove', onMove, { passive: false });
      document.addEventListener('pointerup', onUp, { passive: false });
      document.addEventListener('pointercancel', onUp, { passive: false });
    }, { passive: false });
  }

  function dualNavInit() {
    // Initialize dual-navigation layout

    // Apply saved pane widths to CSS variables.
    document.documentElement.style.setProperty('--dp-root-pane-width', `${_rootPaneWidth}px`);
    document.documentElement.style.setProperty('--dp-leaf-pane-width', `${_leafPaneWidth}px`);

    // Set up drag-resize handlers for both nav panes.
    dualNavResizer();

    // Recalculate layout on window resize.
    window.addEventListener('resize', () => { checkDualNavLayout(); });
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 DUAL NAV FUNCTIONS

  // #region 🟩 GEN DEF TREE
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  async function genDefTree() {
    // Generate a deep clone of the default Doxygen NAVTREE:
    // 1. Wait until window.NAVTREE[0][2] is defined and non-empty (timeout after TIMEOUT_MS).
    // 2. Recursively clone the tree structure into a new array.
    // 3. Dynamically load any external JS files for deferred child nodes.
    // 4. Recursively attach those loaded children.
    // 5. Return the fully expanded tree array, or null on timeout.

    // Wait for NAVTREE[0][2]
    const start = performance.now();
    while (
      !window.NAVTREE ||
      !Array.isArray(window.NAVTREE) ||
      window.NAVTREE.length === 0 ||
      !Array.isArray(window.NAVTREE[0]) ||
      window.NAVTREE[0].length < 3 ||
      !Array.isArray(window.NAVTREE[0][2])
    ) {
      const elapsed = performance.now() - start;
      if (elapsed > TIMEOUT_MS) {
        console.error(`Gen Def Tree: Timed out waiting for selector "NAVTREE[0][2]" after ${elapsed} ms`);
        return null;
      }
      //console.log(`Gen Def Tree: Waiting for "NAVTREE[0][2]" after ${elapsed} ms...`);
      await new Promise(requestAnimationFrame);
    }

    // Makes a deep copy of [name, href, kids] tuples for tree
    function cloneTree(tree) {
      return tree.map(([name, href, kids]) => {
        const clonedKids = Array.isArray(kids) ? cloneTree(kids) : kids;
        return [name, href, clonedKids];
      });
    }

    // Inserts a <script> tag to load a JS file and resolves when loaded
    function loadScript(relUrl) {
      return new Promise((res, rej) => {
        const fullUrl = new URL(relUrl, DOC_ROOT).href; // build an absolute URL from a relative path and a base root.
        const s = document.createElement('script'); s.src = fullUrl; s.async = true; // create and configure a <script> tag.
        s.onload = () => res(); // when the script finishes loading, call resolve()
        s.onerror = err => rej(err); // if the script fails to load, call reject(err)
        document.head.appendChild(s); // insert the <script> tag into the page and kicks off the download.
      });
    }

    // Walks the cloned tree, loads deferred children, and replaces string refs
    function loadChildren(tree) {
      const promises = [];
      tree.forEach(node => {
        const c = node[2];
        if (typeof c === 'string') {
          // c is a script base name: load it then replace node[2] with the loaded array
          promises.push(
            loadScript(c + '.js')
              .then(() => {
                let arr = window[c];
                if (!Array.isArray(arr)) arr = window[c.split('/').pop()];
                node[2] = Array.isArray(arr) ? arr : [];
                return loadChildren(node[2]);
              })
              .catch(() => { node[2] = []; })
          );
        } else if (Array.isArray(c)) {
          // Already an array: recurse
          promises.push(loadChildren(c));
        }
      });
      return Promise.all(promises);
    }

    // Perform clone, load all children, then return the result
    const defTree = cloneTree(window.NAVTREE[0][2]);
    await loadChildren(defTree);
    //console.log('Gen Def Tree: SUCCESS');
    return defTree;
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 GEN DEF TREE

  // #region 🟩 GEN HTML PAGES
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  async function genHtmlPages() {
    // Build or reload the primary navigation tree (_htmlpages) for Doxy-Plus:
    // 1. Clear existing _htmlpages but keep the array reference.
    // 2. If the Doxygen generation timestamp matches the last saved, load cached tree and indentation flag.
    // 3. Otherwise, generate a fresh tree by:
    //    a. Fetching the complete default NAVTREE via genDefTree().
    //    b. Locating key sections (Namespaces, Globals, Concepts, Classes, Files).
    //    c. Flattening and pruning each section into [label, href, null] entries.
    //    d. Appending these sections to _htmlpages in a logical order.
    // 4. Save the new tree and indentation flag back to storage for future reuse.

    // Reset _htmlpages while retaining its reference (i.e. previous links)
    // done by setting its length to 0
    _htmlpages.length = 0;

    // Read the previous stored doxygen time (returns null if nothing was stored)
    const prvDoxyTime = load(KEY__GEN_DATA);

    // Attempt to load from cache if the generation timestamp hasn't changed
    if (prvDoxyTime != null && prvDoxyTime === window.DOXY_PLUS_DATE_TIME) {
      const prvHtmlPages = load(KEY__HTML_PAGES);
      if (prvHtmlPages != null && Array.isArray(prvHtmlPages) && prvHtmlPages.length > 0) {
        // Restore cached tree and indentation state
        _htmlpages.push(...prvHtmlPages);
        _htmlpagesIndented = load(KEY__HTML_PAGES_TREE_INDENTED, false);

        // Saving so that expiry timestamp is updated to a new value
        save(KEY__GEN_DATA, window.DOXY_PLUS_DATE_TIME);
        save(KEY__HTML_PAGES, _htmlpages);
        save(KEY__HTML_PAGES_TREE_INDENTED, _htmlpagesIndented);

        //(`Gen Pri Tree: Loaded from Session Storage`);

        // return since there is no need to process any further data in this function
        return;
      }
    }

    // Flattens a nested [name, path, kids] tree into a flat 
    // array of [prefixedName, path, null] entries. Drops any 
    // node whose path contains “#”. If `filters` is non-empty, 
    // only keeps nodes whose filename starts with one of the 
    // filter strings. Returns null if no nodes survive.
    function flatAndPrune(tree, sep = '', filters = []) {

      const result = [];

      if (!Array.isArray(tree) || tree.length === 0) {
        return result;
      }

      const hasFilter = filters.length > 0;

      (function collect(branch, prefix = '') {
        for (const [name, path, kids] of branch) {
          // build the new hierarchical name
          const prefixedName = prefix ? `${prefix}${sep}${name}` : name;

          // only consider real HTML pages without anchors when there is either no filter or starts with filter
          if (typeof path === 'string') {
            const htmlName = path.split('/').pop();
            if (!htmlName.includes('#') && IS_HTML_END.test(htmlName) && (!hasFilter || filters.some(f => htmlName.startsWith(f)))) {
              result.push([prefixedName, path, null]);
            }
          }

          // recurse into children regardless—so deeper matches still appear
          if (Array.isArray(kids) && kids.length) {
            collect(kids, prefixedName);
          }
        }
      })(tree);

      return result;
    }

    // Traverse a cloned default tree by a sequence of section names
    function findNodeByNameList(tree, ...nameList) {
      if (!Array.isArray(tree) || nameList.length === 0) return null;
      let level = tree;
      let node = null;
      for (const name of nameList) {
        node = level.find(item => item[0] === name) || null;
        if (!node) return null;
        level = Array.isArray(node[2]) ? node[2] : [];
      }
      return node;
    }

    // Obtain the full default Doxygen NAVTREE
    const defTree = await genDefTree();
    if (!Array.isArray(defTree) || defTree.length === 0) {
      console.warn('Gen Pri Tree: Default tree returned by "genDefTree" is either not an array or is empty');
      return;
    }

    /**
     * Extracts anonymous-namespace entries from a flat [label, href, null] list,
     * renames them as:
     *   "anonymous_namespace{file.cpp}"                -> "file.cpp"
     *   "npi::anonymous_namespace{file.cpp}"           -> "file.cpp npi::"
     *   "npi::util::anonymous_namespace{file.cpp}"     -> "file.cpp npi::util::"
     * Removes the extracted entries from the original list and returns a new
     * array sorted case-insensitively by the pretty label.
     *
     * @param {Array<[string, string, null]>} list - Flat namespace items (mutated).
     * @returns {Array<[string, string, null]>} - Pretty, sorted anonymous items.
     */
    function siphonAnonymousNamespaces(list) {
      const out = [];
      if (!Array.isArray(list) || list.length === 0) return out;

      const reAnon = /anonymous_namespace\{([^}]+)\}$/;

      for (let i = list.length - 1; i >= 0; --i) {
        const item = list[i];
        if (!Array.isArray(item) || item.length < 2) continue;

        const label = String(item[0] ?? "");
        const href = item[1];

        const m = reAnon.exec(label);
        if (!m) continue;

        const file = m[1];
        const prefix = label.slice(0, m.index); // may be empty or end with "::"
        const pretty = prefix ? (file + " (" + prefix + ")") : file;

        out.push([pretty, href, null]);
        list.splice(i, 1); // remove in place
      }

      out.sort((a, b) => {
        const A = String(a[0]).toLowerCase();
        const B = String(b[0]).toLowerCase();
        if (A < B) return -1;
        if (A > B) return 1;
        // Optional tie-breaker by href keeps order deterministic
        const aHref = String(a[1] ?? "");
        const bHref = String(b[1] ?? "");
        if (aHref < bHref) return -1;
        if (aHref > bHref) return 1;
        return 0;
      });

      return out;
    }

    // Process the Namespaces -> Namespace List
    const nsListNode = findNodeByNameList(defTree, 'Namespaces', 'Namespace List');
    if (nsListNode) {
      const [, href, kids] = nsListNode;
      if (typeof href === 'string' && IS_HTML_END.test(href) && Array.isArray(kids)) {
        const list = flatAndPrune(kids, '::', ['namespace']);
        const anon = siphonAnonymousNamespaces(list);

        if (anon.length > 0) {
          list.push(['-- ANONYMOUS --', null, null]);
          for (let ii = 0; ii < anon.length; ++ii) {
            list.push([anon[ii][0], anon[ii][1], anon[ii][2]]);
          }
        }

        if (list.length > 0) {
          _htmlpages.push(['Namespaces', href, list]);
        }
      }
    }

    // Process the Namespaces -> Namespace Members
    const nsMemNode = findNodeByNameList(defTree, 'Namespaces', 'Namespace Members');
    if (nsMemNode) {
      const [, href, kids] = nsMemNode;
      if (Array.isArray(kids) && kids.length > 0) {
        let temp = flatAndPrune(kids, '::');
        if (temp.length > 0) {
          let idx = -1;
          for (let ii = 0; ii < temp.length; ++ii) {
            if (temp[ii][0] === 'All') {
              idx = ii;
              break;
            }
          }
          if (idx > -1) {
            let tempHref = temp[idx][1];
            temp.splice(idx, 1);
            if (typeof tempHref === 'string' && IS_HTML_END.test(tempHref) && temp.length > 0) {
              _htmlpages.push(['Globals', tempHref, temp]);
            }
          }
        }
      }
    }

    // Process Concepts
    const conceptsNode = findNodeByNameList(defTree, 'Concepts');
    if (conceptsNode) {
      const [, href, kids] = conceptsNode;
      const list = flatAndPrune(kids, '::', ['concept'])
      if (typeof href === 'string' && IS_HTML_END.test(href) && list.length > 0) {
        _htmlpages.push(['Concepts', href, list]);
      }
    }

    // Process Classes -> Class List. If there are classes added then it sets
    // classListInserted flag to true.
    let classListInserted = false;
    const classListNode = findNodeByNameList(defTree, 'Classes', 'Class List');
    if (classListNode) {
      const [, href, kids] = classListNode;
      const list = flatAndPrune(kids, '::', ['class', 'struct'])
      if (typeof href === 'string' && IS_HTML_END.test(href) && list.length > 0) {
        classListInserted = true;
        _htmlpages.push(['Classes', href, list]);
      }
    }

    // If Classes are added then add 'Class Hierarchy' and 'Class Index' pages
    if (classListInserted) {

      // Adding 'Class Hierarchy' page to Classes Node
      const classHierarchyNode = findNodeByNameList(defTree, 'Classes', 'Class Hierarchy');
      if (classHierarchyNode) {
        const [, href, kids] = classHierarchyNode;
        if (typeof href === 'string' && IS_HTML_END.test(href)) {
          _htmlpages[_htmlpages.length - 1][2].push(['[Hierarchy]', href, null]);
        }
      }

      // Adding 'Class Index' page to Classes Node
      const classIndexNode = findNodeByNameList(defTree, 'Classes', 'Class Index');
      if (classIndexNode) {
        const [, href, kids] = classIndexNode;
        if (typeof href === 'string' && IS_HTML_END.test(href)) {
          _htmlpages[_htmlpages.length - 1][2].push(['[Index]', href, null]);
        }
      }
    }

    // Process Classes -> Class Members
    const classMembersNode = findNodeByNameList(defTree, 'Classes', 'Class Members');
    if (classMembersNode) {
      const [, href, kids] = classMembersNode;
      if (Array.isArray(kids) && kids.length > 0) {
        let temp = flatAndPrune(kids, '::');
        if (temp.length > 0) {
          let idx = -1;
          for (let ii = 0; ii < temp.length; ++ii) {
            if (temp[ii][0] === 'All') {
              idx = ii;
              break;
            }
          }
          if (idx > -1) {
            let tempHref = temp[idx][1];
            temp.splice(idx, 1);
            if (typeof tempHref === 'string' && IS_HTML_END.test(tempHref) && temp.length > 0) {
              _htmlpages.push(['Class Members', tempHref, temp]);
            }
          }
        }
      }
    }

    // Process Files -> Files List
    const filesNode = findNodeByNameList(defTree, 'Files', 'File List');
    if (filesNode) {
      const [, href, kids] = filesNode;
      const list = flatAndPrune(kids, '/', ['_', 'dir_'])
      if (typeof href === 'string' && IS_HTML_END.test(href) && list.length > 0) {
        _htmlpages.push(['Files', href, list]);
      }
    }

    // Process File -> File Members
    const filesMembersNode = findNodeByNameList(defTree, 'Files', 'File Members');
    if (filesMembersNode) {
      const [, href, kids] = filesMembersNode;
      if (Array.isArray(kids) && kids.length > 0) {
        let temp = flatAndPrune(kids, '::');
        if (temp.length > 0) {
          let idx = -1;
          for (let ii = 0; ii < temp.length; ++ii) {
            if (temp[ii][0] === 'All') {
              idx = ii;
              break;
            }
          }
          if (idx > -1) {
            let tempHref = temp[idx][1];
            temp.splice(idx, 1);
            if (typeof tempHref === 'string' && IS_HTML_END.test(tempHref) && temp.length > 0) {
              _htmlpages.push(['File Members', tempHref, temp]);
            }
          }
        }
      }
    }


    // Enable below to add dummy items to the primary tree to see how it works
    // with more than 2 level deep tree structure.
    /*
    _htmlpages.push(['Ind A Bla bla bla bla bla bla bla', null, null]);
    _htmlpages.push(['Ind B Bla bla bla bla bla bla bla', null, null]);

    _htmlpages.push([
      'Level 0',
      null,
      [
        [  // ← child-array starts here
          'Level 1 Bla bla bla bla bla bla bla',
          null,
          [
            ['Level A Bla bla bla bla bla bla bla', null, null],
            ['Level B Bla bla bla bla bla bla bla', null, null],
            ['Level C Bla bla bla bla bla bla bla', null, null],
            [
              'Level 2 Bla bla bla bla bla bla bla',
              null,
              [
                ['Level x Bla bla bla bla bla bla bla', null, null],
                [
                  'Level 3 Bla bla bla bla bla bla bla',
                  null,
                  [
                    [
                      'Level 4 Bla bla bla bla bla bla bla',
                      null,
                      [
                        ['Level 5 Bla bla bla bla bla bla bla', null, null]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]  // ← end of children of Level 0
      ]
    ]);

    _htmlpages.push(['Ind C Bla bla bla bla bla bla bla', null, null]);
    */


    // Compute whether indentation is needed
    _htmlpagesIndented = isTreeIndented(_htmlpages);

    // Save the new data
    save(KEY__GEN_DATA, window.DOXY_PLUS_DATE_TIME);
    save(KEY__HTML_PAGES, _htmlpages);
    save(KEY__HTML_PAGES_TREE_INDENTED, _htmlpagesIndented);

    //console.log(`Gen Pri Tree: Generated`);
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 GEN HTML PAGES

  // #region 🟩 GEN PAGE LINKS
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  async function genPageLinks() {

    function slugify(text) {
      return (text || "")
        .toLowerCase()
        .normalize("NFKD").replace(/[\u0300-\u036f]/g, "") // strip accents
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "")
        .replace(/-{2,}/g, "-")
        .slice(0, 80) || "section";
    }

    const usedIds = new Set();
    function uniqueId(base) {
      let id = base;
      let n = 2;
      while (usedIds.has(id) || document.getElementById(id)) {
        id = base + "-" + n++;
      }
      usedIds.add(id);
      return id;
    }

    function formatSignature(text) {
      if (typeof text !== 'string') return text;

      return text
        // Remove space before *, &, &&
        .replace(/\s+([*&]{1,2})/g, '$1')

        // Ensure space after *, &, &&
        .replace(/([*&]{1,2})(?!\s)/g, '$1 ')

        // Remove spaces inside <...>
        .replace(/<\s+/g, '<')
        .replace(/\s+>/g, '>')
        .replace(/\s+<\s+/g, '<')
        .replace(/\s+>\s+/g, '>')

        // Remove space before commas, ensure one after
        .replace(/\s+,/g, ',')
        .replace(/,(?!\s)/g, ', ')

        // Remove space after ( and before )
        .replace(/\(\s+/g, '(')
        .replace(/\s+\)/g, ')')

        // ❗ Remove space before (
        .replace(/\s+\(/g, '(')

        // Add space before and after = in special cases
        .replace(/\s*=\s*(default|delete|0)/g, ' = $1')

        // Collapse multiple spaces and trim
        .replace(/\s{2,}/g, ' ')

        // leading “}”
        .replace(/^\}+\s*/, '')

        // trailing “{”
        .replace(/\s*\{+$/, '')

        .trim();
    }

    _pageLinks.length = 0;
    _pageLinksRemark = '';

    const contents = await waitFor('div.contents, div.content, main');
    if (!contents) {
      console.error('Gen Page Links: wait for "div.contents, div.content, main" timed out, not found');
      return;
    }

    const tables = Array.from(contents.querySelectorAll("table.memberdecls"));
    if (tables.length > 0) {
      tables.forEach((table, idx) => {
        const grpSigs = [];
        const seenName = new Set();
        const seenHref = new Set();

        const headerEl = table.querySelector("h2.groupheader");
        if (!headerEl) return;

        let headName = `Members ${idx + 1}`;
        let headHref = `dp-table-${idx + 1}`;
        const headLabel = (headerEl.textContent || "").replace(/\s+/g, " ").trim();
        if (headLabel) {
          headName = headLabel;
          const hBase = "dp-" + slugify(headLabel);
          headHref = uniqueId(hBase);
        }

        _sectionMap.set(headHref, headerEl); // const _sectionMap =  new Map();

        table.querySelectorAll("a[href^='#']").forEach(a => {
          if (a.closest("div.memdoc") || a.closest("td.mdescRight")) return;

          const leafHref = a.getAttribute("href");
          if (seenHref.has(leafHref)) {
            return;
          }

          const row = a.closest("tr");
          if (!row) {
            return;
          }
          const tds = row.querySelectorAll("td");
          if (tds.length < 2) {
            return;
          }

          const lftText = tds[0].innerText.replace(/\s+/g, ' ').trim();
          const ritText = tds[1].innerText.replace(/\s+/g, ' ').trim();
          let leafNameTemp = `${lftText} ${ritText}`.trim();
          let leafName = formatSignature(leafNameTemp);
          if (leafName.startsWith('enum')) {
            leafName = leafName.replace(/\s*\{[\s\S]*\}/, '').trim();
          }
          if (seenName.has(leafName)) {
            return;
          }

          seenHref.add(leafHref);
          seenName.add(leafName);

          grpSigs.push([leafName, leafHref, null]);
        });

        // Add this group if it has entries
        if (grpSigs.length > 0) {
          _pageLinks.push([headName, headHref, grpSigs]);
        }
      });
    }
    else {
      _pageLinksRemark = 'Empty "table.memberdecls" element array';
    }

    if (_pageLinks.length > 0) {
      document.body.setAttribute('data-dp-page-links-tree-available', '');
      _pageLinksRemark = 'Successfully generated member signatures';
    }
    else {
      document.body.removeAttribute('data-dp-page-links-tree-available');
      _pageLinksRemark = 'No member signature found';
    }
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 GEN PAGE LINKS

  // #region 🟩 CHECK RELOAD
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  function checkReload() {
    // Check for a saved URL and redirect to it if it matches an entry in the html pages tree on a fresh load.

    function check() {
      // Guard #1: only proceed on a truly fresh tab (not after reload/back/forward)
      const isFresh = (sessionStorage.getItem('is_stale') !== 'true');
      sessionStorage.setItem('is_stale', 'true');
      if (!isFresh) return true; // Not a fresh load: skip redirect check

      // Guard #2: html pages tree data must be available
      if (!Array.isArray(_htmlpages) || !_htmlpages.length) return true; // No tree data: skip redirect

      // Guard #3: only on standard navigation (ignore reloads and history traversals)
      let navType = 'navigate';
      const [navEntry] = performance.getEntriesByType('navigation');
      if (navEntry) {
        navType = navEntry.type;
      } else if (performance.navigation) {
        // fallback for older browsers (deprecated API)
        navType = performance.navigation.type === 1 ? 'reload' : 'navigate';
      }
      if (navType !== 'navigate') return true; // Reload or back/forward: skip redirect

      // Guard #4: storedUrl must exist and start with DOC_ROOT
      const storedUrl = load(KEY__PREV_URL);
      if (!storedUrl || !storedUrl.startsWith(DOC_ROOT) || storedUrl.endsWith('/') || storedUrl.endsWith('/index.html')) return true; // Missing or external URL: skip redirect

      // Guard #5: only run on landing page (root or index.html)
      const { pathname } = new URL(window.location.href);
      const isLanding = pathname.endsWith('/') || pathname.endsWith('/index.html');
      if (!isLanding) return true; // Not on landing page: skip redirect

      // Traverse the html pages tree to find a matching HTML page in the stored URL
      const stack = [..._htmlpages];
      while (stack.length) {
        const [, href, kids] = stack.pop();
        if (typeof href === 'string' && IS_HTML_END.test(href) && storedUrl.includes(href)) {
          window.location.replace(storedUrl); // Redirect on first match
          return false;  // stop after first match
        }
        if (Array.isArray(kids) && kids.length) {
          stack.push(...kids);
        }
      }

      return true;
    }

    const attach = check();
    if (attach) {
      window.addEventListener('hashchange', () => { save(KEY__PREV_URL, window.location.href); });
      window.addEventListener('pagehide', () => { save(KEY__PREV_URL, window.location.href); }, { once: true });
      window.addEventListener('beforeunload', () => { save(KEY__PREV_URL, window.location.href); }, { once: true });
    }
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 CHECK RELOAD

  // #region 🟩 DOC HEADER AND OBSERVERS
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  async function setupResizeObservers() {
    // Clones the header of the doc-content section and attaches it above it so that scrolling the doc-content
    // does not make its header disappear (the default behaviour).
    // Looks for the size changes in the required elements and updates those values in the doxy-plus.css file

    // Wait for all required elements: top bar, side-nav, breadcrumb/nav-path, and doc-content.
    const [top, nav, btm, doc, con] = await Promise.all([waitFor('#top'), waitFor('#side-nav'), waitFor('#nav-path'), waitFor('#doc-content'), waitFor('#container')]);

    // Clone the header inside #doc-content and insert it above so it stays visible on scroll.
    let cln = null;
    if (con && con.parentElement) {
      const header = document.querySelector('#doc-content .header');
      if (header) {
        cln = header.cloneNode(true);
        cln.removeAttribute('id');
        con.parentElement.insertBefore(cln, con);
      }
    }

    if (cln) document.body.setAttribute('data-dp-doc-header-available', '');
    else document.body.removeAttribute('data-dp-doc-header-available');

    const pge = document.getElementById('page-nav');
    if (pge) document.body.setAttribute('data-dp-page-nav-available', '');
    else document.body.removeAttribute('data-dp-page-nav-available');

    // If none of the observed elements exist (including the cloned header), do nothing.
    if (!top && !nav && !btm && !cln) return;

    // Single ResizeObserver to update CSS vars when these elements resize.
    const ro = new ResizeObserver(entries => {
      for (const { target, contentRect } of entries) {
        if (target === top) {
          const hTop = contentRect.height;
          const ta = document.getElementById('titlearea');
          if (ta && ta.getBoundingClientRect().height !== hTop)
            document.body.setAttribute('data-dp-main-nav-below-title', '');
          else
            document.body.removeAttribute('data-dp-main-nav-below-title');
          document.documentElement.style.setProperty('--dp-header-height', `${hTop}px`);
        } else if (target === nav) {
          document.documentElement.style.setProperty('--dp-side-nav-width', `${contentRect.width}px`);
        } else if (target === btm) {
          document.documentElement.style.setProperty('--dp-footer-height', `${contentRect.height}px`);
        } else if (target === cln) {
          document.documentElement.style.setProperty('--dp-doc-header-height', `${contentRect.height}px`);
        }
      }
    });

    // start observing, this will trigger the first update soon after and will automatically
    // update the values, so no need to fire it once in the beginning manually.
    if (top) ro.observe(top);
    if (nav) ro.observe(nav);
    if (btm) ro.observe(btm);
    if (cln) ro.observe(cln);
  }

  async function searchResultWindowObserver() {
    // Syncs the search results window position and width to match the search bar when shown.

    // Wait for the search results window element (always in DOM but hidden until a search runs).
    const sWin = await waitFor('#MSearchResultsWindow');
    if (!sWin) {
      console.error('Search Result Window Observer: wait for "#MSearchResultsWindow" timed out, not found');
      return;
    }

    async function syncSize() {
      // Align the search results window's left position and width to the active search box.

      // Choose which search box container is active:
      // 'searchBoxPos1' for mobile (<768px) and 'searchBoxPos2' for desktop (>=768px).
      const parentId = window.innerWidth < 768 ? 'searchBoxPos1' : 'searchBoxPos2';

      // Get the search box element inside that container.
      const sBox = await waitFor(`#${parentId} #MSearchBox`);
      if (!sBox) return;

      // Measure the search box's left offset and width.
      const { left, width } = sBox.getBoundingClientRect();

      // Apply the measured left and width to the persistent search results window.
      sWin.style.setProperty('left', `${left}px`, 'important');
      sWin.style.setProperty('width', `${width}px`, 'important');
      //console.log(`Search Result Window Observer - Sync Size: Set size X=${left}px & W=${width}px`);
    }

    // Track whether the results window is currently displayed,
    // so we only sync once when it opens.
    let isDisplayed = getComputedStyle(sWin).display === 'block';

    // Observe style changes on the search results window to detect show/hide.
    const mo = new MutationObserver(records => {
      // only look for transitions into display:block
      for (const rec of records) {
        // Only handle style attribute mutations.
        if (rec.attributeName !== 'style') continue;
        const nowDisplay = getComputedStyle(sWin).display === 'block';
        if (!isDisplayed && nowDisplay) {
          // Window just shown: sync size.
          isDisplayed = true;
          syncSize();
        } else if (isDisplayed && !nowDisplay) {
          // Window just hidden: update state.
          isDisplayed = false;
        }
        // otherwise ignore
      }
    });

    // Begin observing style mutations on the search results window.
    mo.observe(sWin, { attributes: true, attributeFilter: ['style'] });
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 DOC HEADER AND OBSERVERS

  // #region 🟩 BUILD TREES
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  async function buildTrees() {

    // Wait for both nav containers to be available in the DOM and remove any html value in these
    const [root_pane, leaf_pane] = await Promise.all([waitFor('#dp-root-pane'), waitFor('#dp-leaf-ul')]);
    if (!root_pane || !leaf_pane) {
      console.error('Build Trees: Root or Leaf panel is not available');
      return;
    }
    root_pane.innerHTML = '';
    //leaf_pane.innerHTML = '';

    const CLS = {
      list: 'dp-tree-list',
      item: 'dp-tree-item',
      line: 'dp-tree-line',
      node: 'dp-tree-node',
      link: 'dp-tree-link',
      itemCurrent: 'dp-tree-item--current',
      itemVisited: 'dp-tree-item--visited',
      itemDisabled: 'dp-tree-item--disabled',
      itemNodeOpen: 'dp-tree-item--node-open',
      itemHasChildren: 'dp-tree-item--has-children',
      itemHasUrl: 'dp-tree-item--has-url',
      itemHasPageSectionId: 'dp-tree-item--has-page-section-id',
    };

    // Configurations
    const CONFIG = {
      root_cfg: {
        data: _htmlpages,
        key: KEY__HTML_PAGES_TREE_EXPANDED_NODES,
        prefix: 'ROOT:',
        mainSet: _htmlPagesExpandedNodes,
        defaultOpen: false,
        setOpen: (id, isOpen) => isOpen ? _htmlPagesExpandedNodes.add(id) : _htmlPagesExpandedNodes.delete(id),
        saveDebounced: debounce(() => save(KEY__HTML_PAGES_TREE_EXPANDED_NODES, Array.from(_htmlPagesExpandedNodes)), 500)
      },
      leaf_cfg: {
        data: _pageLinks,
        key: HTML_NAME,
        prefix: 'LEAF:',
        mainSet: _pageLinksCollapsedNodes,
        defaultOpen: true,
        setOpen: (id, isOpen) => isOpen ? _pageLinksCollapsedNodes.delete(id) : _pageLinksCollapsedNodes.add(id),
        saveDebounced: debounce(() => save(HTML_NAME, Array.from(_pageLinksCollapsedNodes)), 500)
      }
    };

    // Function to build the tree
    function build(kind = 'root_cfg') {

      // verifying
      if (!CONFIG[kind]) {
        console.error(`Build Trees - Build: "${kind}" is not a valid parameter.`);
        return document.createDocumentFragment();
      }

      const cfg = CONFIG[kind];
      const tree = cfg.data;
      if (!Array.isArray(tree) || tree.length === 0) {
        console.log(`Build Trees - Build: "${kind}" data empty or invalid. Returning.`);
        return document.createDocumentFragment();
      }

      // clear out any prior state for expanded/collapsed nodes, this will be filled as the tree is built
      cfg.mainSet.clear();

      // load previous expanded/collapsed nodes state in a separate set for comparison later on
      let prvAry = [];
      const rawAry = load(cfg.key, []);
      if (Array.isArray(rawAry)) prvAry = rawAry;
      else console.warn(`Expected array for "${cfg.key}", got:`, rawAry);
      const prvSet = new Set(prvAry);

      // Create root <ul> as the tree container.
      const rootUl = document.createElement('ul');
      rootUl.classList.add(CLS.list);
      rootUl.setAttribute('role', 'tree');

      // stack for iterative build and start building
      const stack = [{ branch: tree, parentUl: rootUl, level: [] }];
      while (stack.length) {

        const { branch, parentUl, level } = stack.pop();
        const fragment = document.createDocumentFragment();

        branch.forEach(([name, path, kids], idx) => {

          const li = document.createElement('li');
          li.classList.add(CLS.item);
          li.setAttribute('role', 'treeitem');

          // compute ID for expanded/collapsed node data e.g. ROOT:1.2.0.file_name
          const thisLevel = [...level, idx];
          const fileBase = (typeof path === 'string' && path.length > 0) ? (kind === 'root_cfg' ? path.split('/').pop().replace(/\..*$/, '') : path) : null;
          const id = `${cfg.prefix}${thisLevel.join('.')}.${fileBase}`;
          li.setAttribute('data-dp-tree-item-id', id);

          // Container for li to have its own expand/collapse button and label
          const line = document.createElement('div');
          line.classList.add(CLS.line);

          // Expand/Collapse button
          const node = document.createElement('button');
          node.classList.add(CLS.node);
          node.textContent = "\u2B9E"; // ⮞, rotated to show open state
          node.setAttribute('type', 'button');
          line.append(node);

          // Label
          if (typeof path === 'string' && path.startsWith('dp-')) {
            li.classList.add(CLS.itemHasPageSectionId);
            const link = document.createElement('button');
            link.classList.add(CLS.link);
            link.type = 'button';
            link.textContent = name;
            link.title = name; // tooltip
            link.setAttribute('data-dp-tree-item-page-section-id', path);
            line.append(link);
          }
          else {
            const link = document.createElement('a');
            link.classList.add(CLS.link);
            link.textContent = name;
            link.title = name; // tooltip
            if (typeof path === 'string' && path.length > 0) {
              li.classList.add(CLS.itemHasUrl);
              if (kind === 'root_cfg') link.href = DOC_ROOT + path;
              else link.href = path;
            }
            else {
              li.classList.add(CLS.itemDisabled);
              link.removeAttribute('href');
              link.setAttribute('aria-disabled', 'true');
              link.setAttribute('tabindex', '-1');
            }
            line.append(link);
          }

          // attach line as child of li
          li.appendChild(line);

          // Make a ul for item children
          if (Array.isArray(kids) && kids.length) {

            // Itentifier for li having children
            li.classList.add(CLS.itemHasChildren);

            // Expanded/Collapsed state of item
            const isOpen = prvSet.has(id) ? !cfg.defaultOpen : cfg.defaultOpen;
            node.setAttribute('aria-expanded', String(isOpen));
            if (isOpen) li.classList.add(CLS.itemNodeOpen);
            cfg.setOpen(id, isOpen); // writes data for storage when cfg.saveDebounced(); is called

            // Child list
            const childUl = document.createElement('ul');
            const gid = `grp-${id}`;
            childUl.id = gid;
            node.setAttribute('aria-controls', gid);
            childUl.classList.add(CLS.list);
            childUl.setAttribute('role', 'group');
            li.appendChild(childUl);

            // push children for processing
            stack.push({ branch: kids, parentUl: childUl, level: thisLevel });
          }
          else {
            node.setAttribute('aria-hidden', 'true');
            node.disabled = true;
          }

          // append the item <li> to its parent list <ul> fragment
          fragment.appendChild(li);
        });

        parentUl.appendChild(fragment);
      }

      // save initial state of expanded/collapsed nodes and return the main <ul>
      cfg.saveDebounced();
      return rootUl;
    }

    // Set the current item
    function setCurrentTreeItem(container, kind = 'root_cfg') {

      // verify
      if (!container || !CONFIG[kind]) {
        console.error(`Build Trees - Set Current Tree Item: Invalid parameter. Returning.`);
        return;
      }
      const cfg = CONFIG[kind];

      // clear previous current item
      const prev = container.querySelector(`.${CLS.itemCurrent}`);
      if (prev) prev.classList.remove(CLS.itemCurrent);

      // Find new target
      const target = kind === 'root_cfg' ? window.location.href.split('#')[0] : window.location.hash;
      if (!target) return;

      // Search for the item that has the target link
      for (const link of container.querySelectorAll(`.${CLS.link}[href]`)) {
        if (link.getAttribute('href') === target) {

          const item = link.closest(`.${CLS.item}`);
          item.classList.add(CLS.itemCurrent);
          item.classList.add(CLS.itemVisited);

          // expand ancestors
          let parent = item.parentElement.closest(`.${CLS.item}`);
          while (parent) {

            parent.classList.add(CLS.itemNodeOpen);
            const btn = parent.querySelector(`:scope > .${CLS.line} > .${CLS.node}`);
            if (btn) btn.setAttribute('aria-expanded', 'true');

            // get the id so that its expanded state can be saved
            const id = parent.getAttribute('data-dp-tree-item-id');
            cfg.setOpen(id, true);

            // recurse over its parent
            parent = parent.parentElement.closest(`.${CLS.item}`);
          }

          // scroll into view this item
          item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

          // break the loop since we have found the item
          break;
        }
      }

      // save the expanded/collapsed state
      cfg.saveDebounced();
    }

    function clickHandler(evt) {

      // 1) Node toggle (chevron)
      const nodeEl = evt.target.closest(`.${CLS.node}`);
      if (nodeEl) {
        const li = nodeEl.closest(`.${CLS.item}`);
        if (!li || !li.classList.contains(CLS.itemHasChildren)) return;

        const id = li.getAttribute('data-dp-tree-item-id');
        const isOpen = li.classList.toggle(CLS.itemNodeOpen);
        nodeEl.setAttribute('aria-expanded', String(isOpen));

        const cfg = id && id.startsWith('ROOT:') ? CONFIG.root_cfg : CONFIG.leaf_cfg;
        cfg.setOpen(id, isOpen);
        cfg.saveDebounced();
        return;
      }

      // 2) Line click -> forward to its link (anchor or button)
      const line = evt.target.closest(`.${CLS.line}`);
      if (!line) return;

      const li = line.closest(`.${CLS.item}`);
      if (!li || li.classList.contains(CLS.itemDisabled)) return;

      const t = line.querySelector(`.${CLS.link}`);
      if (!t) return;

      // 2a) Real link
      if (t.hasAttribute('href') && t.getAttribute('href') !== '#') {
        const id = li.getAttribute('data-dp-tree-item-id');
        if (id && id.startsWith('LEAF:'))
          li.classList.add(CLS.itemVisited);
        t.click();               // let browser navigate
        return;
      }

      // 2b) Section button
      const secId = t.getAttribute('data-dp-tree-item-page-section-id');
      if (secId) {
        const el = _sectionMap.get(secId);
        if (el && el.matches('h2.groupheader')) {
          el.scrollIntoView({ block: 'start', inline: 'nearest', behavior: 'smooth' });
          // optional: el.setAttribute('tabindex','-1'); el.focus({ preventScroll: true });
        }
      }
    }

    function getVisibleItems(container) {
      const result = [];
      function walk(ul) {
        for (const li of ul.querySelectorAll(`:scope > li.${CLS.item}`)) {
          if (!li.classList.contains(CLS.itemDisabled))
            result.push(li);
          if (li.classList.contains(CLS.itemHasChildren) && li.classList.contains(CLS.itemNodeOpen)) {
            const childUl = li.querySelector(`:scope > ul.${CLS.list}`);
            if (childUl)
              walk(childUl);
          }
        }
      }
      for (const topUl of container.querySelectorAll(`:scope > ul.${CLS.list}`)) {
        if (topUl)
          walk(topUl);
      }
      return result;
    }

    function keyHandler(evt) {

      const focusables = getVisibleItems(leaf_pane);
      if (!Array.isArray(focusables) || focusables.length < 2) return;
      const idx = focusables.indexOf(leaf_pane.querySelector(`.${CLS.itemCurrent}`));

      // if there is no current item then return because we will not be able to determine up or down items
      if (idx === -1) return;

      // get the config
      const cfg = CONFIG.leaf_cfg;

      switch (evt.key) {
        case 'ArrowDown': {
          evt.preventDefault();
          const nIdx = idx + 1;
          if (nIdx < focusables.length) focusables[nIdx].querySelector(`.${CLS.line} > .${CLS.link}`).click();
          break;
        }
        case 'ArrowUp': {
          evt.preventDefault();
          const nIdx = idx - 1;
          if (nIdx >= 0) focusables[nIdx].querySelector(`.${CLS.line} > .${CLS.link}`).click();
          break;
        }
        case 'ArrowRight': {
          evt.preventDefault();

          // get the hasChildren, open state and node object
          const hasChildren = focusables[idx].classList.contains(CLS.itemHasChildren);
          const isOpen = focusables[idx].classList.contains(CLS.itemNodeOpen);
          const node = focusables[idx].querySelector(`:scope > .${CLS.line} > .${CLS.node}`);

          if (hasChildren && node && !isOpen) {
            const id = focusables[idx].getAttribute('data-dp-tree-item-id');
            focusables[idx].classList.add(CLS.itemNodeOpen);
            node.setAttribute('aria-expanded', 'true');
            cfg.setOpen(id, true);
            cfg.saveDebounced();
          }
          break;
        }
        case 'ArrowLeft': {
          evt.preventDefault();

          // For the current item, check if it has children, is open and get its node and parent
          const hasChildren = focusables[idx].classList.contains(CLS.itemHasChildren);
          const isOpen = focusables[idx].classList.contains(CLS.itemNodeOpen);
          const parLi = focusables[idx].parentElement?.parentElement;
          const node = focusables[idx].querySelector(`:scope > .${CLS.line} > .${CLS.node}`);

          if (hasChildren && node && isOpen) {
            const id = focusables[idx].getAttribute('data-dp-tree-item-id');
            focusables[idx].classList.remove(CLS.itemNodeOpen);
            node.setAttribute('aria-expanded', 'false');
            cfg.setOpen(id, false);
            cfg.saveDebounced();
          }
          else if (parLi && parLi.matches(`.${CLS.item}`)) {
            const parHasChildren = parLi.classList.contains(CLS.itemHasChildren);
            const parIsOpen = parLi.classList.contains(CLS.itemNodeOpen);
            const parNode = parLi.querySelector(`:scope > .${CLS.line} > .${CLS.node}`);

            if (parHasChildren && parNode && parIsOpen) {
              const id = parLi.getAttribute('data-dp-tree-item-id');
              parLi.classList.remove(CLS.itemNodeOpen);
              parNode.setAttribute('aria-expanded', 'false');
              cfg.setOpen(id, false);
              cfg.saveDebounced();

              // simulate a click on parent node
              parLi.querySelector(`:scope > .${CLS.line} > .${CLS.link}`).click();
            }
          }
          break;
        }
        case 'Home': {
          evt.preventDefault();
          focusables[0].querySelector(`:scope > .${CLS.line} > .${CLS.link}`).click();
          break;
        }
        case 'End': {
          evt.preventDefault();
          focusables[focusables.length - 1].querySelector(`:scope > .${CLS.line} > .${CLS.link}`).click();
          break;
        }
      }
    }

    if (_htmlpagesIndented) root_pane.classList.add('dp-pane-has-indented-tree');
    const rootTree = build('root_cfg');
    root_pane.appendChild(rootTree);
    setCurrentTreeItem(root_pane, 'root_cfg');
    rootTree.addEventListener('click', clickHandler);

    if (_pageLinks.length > 0) {
      if (isTreeIndented(_pageLinks)) leaf_pane.classList.add('dp-pane-has-indented-tree');
      const leafTree = build('leaf_cfg');
      leaf_pane.appendChild(leafTree);
      setCurrentTreeItem(leaf_pane, 'leaf_cfg');
      leafTree.addEventListener('click', clickHandler);

      // install the hash changed listner for the secondary tree, so that it updates the current item
      // on hash change. This way whenever hash is changed by clicking a link in secondary tree or
      // in the default side-nav of doxygen the current item in secondary tree is always up to date.
      window.addEventListener('hashchange', () => { setCurrentTreeItem(leaf_pane, 'leaf_cfg'); });

      // We check if the last portion clicked was the secondary tree, so that we can react to key
      // down events on secondary tree
      let leaf_pane_active = false; // by default the last portion clicked is not on secondary tree
      document.addEventListener('mousedown', evt => {
        // in the mouse down event on the entire page, we see get the point where mouse was clicked
        // and if it is over secondary container then we set secondary tree as active so that we
        // can react to key down events
        const hit = document.elementFromPoint(evt.clientX, evt.clientY);
        leaf_pane_active = !!(hit && hit.closest && hit.closest('#dp-leaf-pane'));
      }, true);

      // listening to key down events, inside the event we check if secondary tree is active, and then react
      // to only a given set of keyboard keys by sending the event to our keyHandler function above
      document.addEventListener('keydown', evt => {
        if (leaf_pane_active) {
          if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End'].includes(evt.key)) return;
          keyHandler(evt);
        }
      });
    }
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 BUILD TREES

  // #region 🟩 DISPLAY DEF TREE
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  async function displayDefTree(groupFormat = true) {
    // Generate and display the default Doxygen NAVTREE.
    // Use grouped view when groupFormat is true; otherwise, use table view.

    // generating the default Doxygen NAVTREE
    const defTree = await genDefTree();

    // If the tree has entries, render in the selected format
    if (Array.isArray(defTree) && defTree.length > 0) {
      if (groupFormat) {
        // Render NAVTREE in grouped format
        printTreeGroupFormat(defTree);
      }
      else {
        // Render NAVTREE in table format
        printTreeTableFormat(defTree);
      }
    }
    else {
      // Log an error if the default NAVTREE is EMPTY
      console.error('Default Doxygen NAVTREE Tree is EMPTY');
    }
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 DISPLAY DEF TREE

  // #region 🟩 DISPLAY MISSED HTML PAGES
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  async function displayMissedHtmlPages() {
    // Display any HTML pages present in the default Doxygen NAVTREE but missing from the Doxy-Plus primary tree.

    // Build a set of all HTML pages seen in the _htmlPages
    const seenHtml = new Set();
    if (Array.isArray(_htmlpages) && _htmlpages.length > 0) {
      (function markSeen(tree) {
        // Return if tree is empty or not an array
        if (!Array.isArray(tree) || tree.length === 0) return;
        for (const [, href, kids] of tree) {
          if (typeof href === 'string' && IS_HTML_END.test(href) && !seenHtml.has(href)) {
            // Add HTML links to the seenHtml set
            seenHtml.add(href);
          }
          if (Array.isArray(kids)) markSeen(kids); // Recurse into child nodes
        }
      })(_htmlpages);
    }

    // Generate the default Doxygen NAVTREE for comparison
    const defTree = await genDefTree();

    // If default tree is valid, compare and collect any missing pages
    if (Array.isArray(defTree) && defTree.length > 0) {
      const collected = new Set();
      let missedPages = [];

      (function collect(tree, parName = '') {
        // Return if tree is empty or not an array
        if (!Array.isArray(tree) || tree.length === 0) return;

        for (const [name, href, kids] of tree) {
          // Build full name path using arrows for nesting
          const fullName = parName === '' ? name : parName + " → " + name;

          if (typeof href === 'string') {
            // Strip on-page-link/fragment-identifiers from links
            const link = href.replace(/(\.html)#.*$/, '$1');
            // If link is HTML, unseen, and not already collected, record it
            if (IS_HTML_END.test(link) && !seenHtml.has(link) && !collected.has(link)) {
              collected.add(link);
              missedPages.push({ Name: fullName, Link: link });
            }
          }

          // Recurse into child nodes
          if (Array.isArray(kids)) collect(kids, fullName);
        }
      })(defTree);

      if (missedPages.length > 0) {
        // Display a table of missed pages in the console
        console.table(missedPages);
      }
      else {
        // Inform that there are no missing HTML pages
        console.log('Missed HTML Pages list is EMPTY');
      }
    }
    else {
      // Log an error if the default NAVTREE could not be retrieved
      console.error('Unable to get Default NAVTREE');
    }
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 DISPLAY MISSED HTML PAGES

  // #region 🟩 PURGE EXPIRED DATA
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  function purgeExpiredData() {
    // Purges expired data stored by store.js for this origin, runs at most once per day.

    // Purges data for the entire origin. Origin is the url if hosted otherwise
    // if opened from local disk then all projects share the same local origin in browser

    // Determine today's date in YYYY-MM-DD format.
    const today = new Date().toISOString().slice(0, 10);

    // Get last purge date to avoid multiple purges in one day.
    const lastPurged = localStorage.getItem(KEY__EXPIRED_DATA_PURGE_DATE);
    if (lastPurged === today) return;

    // Actual purge logic: iterates all keys and removes expired entries.
    function purge() {
      const PRE = '__storejs___storejs_'; // Prefix used by store.js for localStorage keys
      const SEP = '_expire_mixin_';       // Separator indicating expiry metadata

      try {
        Object.keys(localStorage).forEach(fullKey => {
          // Only process keys matching the expiry pattern
          if (fullKey.startsWith(PRE) && fullKey.indexOf(SEP, PRE.length) !== -1) {
            // Extract namespace and actual key
            const [nsName, actualKey] = fullKey.slice(PRE.length).split(SEP, 2);
            // Accessing the key via store.js will remove it if expired
            store.namespace(nsName).get(actualKey);
          }
        });
      } catch (err) {
        // Log any errors encountered during purge
        console.warn('Purge Expired Data Error:', err);
      }

      // Record today's date as the last purge time
      localStorage.setItem(KEY__EXPIRED_DATA_PURGE_DATE, today);
    }

    // Schedule the purge during an idle period if available, otherwise use a timeout
    if ('requestIdleCallback' in window) {
      requestIdleCallback(purge, { timeout: 5000 });
    } else {
      setTimeout(purge, 5000);
    }
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 PURGE EXPIRED DATA

  // #region 🟩 CONSOLE OBJECT
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  const consoleObject = Object.create(null); // main object

  // ⚠️ In this section comments are provided as console.log values because it should also be displayed in console

  Object.defineProperty(consoleObject, 'last_update', { // Last Update Date-Time
    get() {
      console.log(`Updated On: ${window.DOXY_PLUS_DATE_TIME}`);
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'project_root', { // Project Root Location
    get() {
      console.log(`${DOC_ROOT}\n\nIf the project is hosted on GitHub, the root is the origin URL plus the repository name; otherwise, it defaults to the local folder path on disk.`);
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'project_namespace', { // Project Namespace
    get() {
      console.log(`${PROJ_NAMESPACE}\n\nThis namespace is used by Doxy-Plus to store project data. Doxy-Plus uses store.js's (https://github.com/marcuswestin/store.js) namespace feature. Assigning each project its own namespace ensures that data remains isolated and cannot conflict with other projects.\n\nBy default, store.js uses the browser's localStorage, which namespaces data by origin. As a result, projects sharing the same origin (e.g. some.com/proj_a and some.com/proj_b) will share the same storage. Likewise, projects loaded from different disk locations (e.g. D:/file/proj_a and E:/other/proj_b) also end up using the same localStorage.`);
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'storage_clear_all', { // To clear all storage
    get() {
      localStorage.clear();
      sessionStorage.clear();
      console.log(`Storage Clear All: Done!\n\n All data stored at this origin (for example, both some.com/proj_a and some.com/proj_b have same origin and all projects on local disk e.g. D:/file/proj_a and E:/other/proj_b share same origin) have been cleared`);
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'storage_local', { // Browser localStorage
    get() {
      console.group('● Browser Local Storage');
      console.log(`Displays the current contents of the browser's localStorage, including default entries and data from all projects. The browser's localStorage persists on disk indefinitely until explicitly cleared.\n\nProject data saved by Doxy-Plus includes an expiration (using store.js: https://github.com/marcuswestin/store.js) and will be removed the next time it's accessed (for example, when opening a project on the same origin). Entries written by store.js use a special signature, so their raw values may appear as “garbage”. To decode them correctly, always read using ${_consoleObjectName}.storage_origin (for all projects) or ${_consoleObjectName}.storage_project (for this project).`);
      const table = [];
      Object.keys(localStorage).forEach(fullKey => {
        table.push({
          Key: fullKey,
          Value: localStorage.getItem(fullKey)
        })
      });
      if (table.length > 0) {
        console.table(table);
      }
      else {
        console.log('Browser Local Storage is EMPTY');
      }
      console.groupEnd();
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'storage_session', { // Browser sessionStorage
    get() {
      console.group('● Browser Session Storage Contents');
      console.log(`Browser sessionStorage: Displays the current contents of the browser's sessionStorage. The browser's sessionStorage persists for the lifetime of the tab—surviving reloads—but is cleared when the tab is closed. Doxy-Plus (through store.js: https://github.com/marcuswestin/store.js) uses it as a fallback storage location. By default there are no data stored by Doxy-Plus in browser's sessionStorage.`);
      const table = [];
      Object.keys(sessionStorage).forEach(fullKey => {
        table.push({
          Key: fullKey,
          Value: sessionStorage.getItem(fullKey)
        })
      });
      if (table.length > 0) {
        console.table(table);
      }
      else {
        console.log('Browser Session Storage is EMPTY');
      }
      console.groupEnd();
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'storage_project', { // Project Storage
    get() {
      console.group('● Project Storage Contents');
      console.log(`Displays the data stored by Doxy-Plus for the current project. Doxy-Plus uses store.js (https://github.com/marcuswestin/store.js) to save project data within a project-specific namespace in browser's localStorage and to enforce an expiry timeout. When a project opens, data from all projects on the same origin—for example, some.com/proj_a and some.com/proj_b, or local files D:/file/proj_a and E:/other/proj_b—is checked for expiry, and any expired entries are removed.`);
      const table = [];
      const PRE = '__storejs___storejs_';
      const SEP = '_expire_mixin_';
      Object.keys(localStorage).forEach(fullKey => {
        if (fullKey.startsWith(PRE) && fullKey.indexOf(SEP, PRE.length) !== -1) {
          const rem = fullKey.slice(PRE.length);
          const [nsName, actualKey] = rem.split(SEP, 2);
          if (nsName === PROJ_NAMESPACE) {
            const expiresAt = STORAGE.getExpiration(actualKey);
            const isExpired = expiresAt != null && Date.now() > expiresAt;
            table.push({
              Namespace: PROJ_NAMESPACE,
              Key: actualKey,
              Value: STORAGE.get(actualKey),
              Validity: expiresAt
                ? new Date(expiresAt).toLocaleString()   // local date/time
                : null,
              Expired: isExpired
            });
          }
        }
      });
      if (table.length > 0) {
        console.table(table);
      }
      else {
        console.log('Project Storage is EMPTY');
      }
      console.groupEnd();
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'storage_origin', { // Origin Storage
    get() {
      console.group('● Origin Storage Contents');
      console.log(`Displays the data stored by Doxy-Plus for all projects at the current origin. Projects share the same origin, for example, some.com/proj_a and some.com/proj_b share the same origin, or local files D:/file/proj_a and E:/other/proj_b share the same origin of being local. Doxy-Plus uses store.js (https://github.com/marcuswestin/store.js) to save project data within a project-specific namespace in browser's localStorage and to enforce an expiry timeout. When a project opens, data from all projects on the same origin is checked for expiry, and any expired entries are removed.`);
      const table = [];
      const PRE = '__storejs___storejs_';
      const SEP = '_expire_mixin_';
      Object.keys(localStorage).forEach(fullKey => {
        if (fullKey.startsWith(PRE) && fullKey.indexOf(SEP, PRE.length) !== -1) {
          const rem = fullKey.slice(PRE.length);
          const [nsName, actualkey] = rem.split(SEP, 2);
          const nsStore = store.namespace(nsName);
          const expiresAt = nsStore.getExpiration(actualkey);
          const isExpired = expiresAt != null && Date.now() > expiresAt;
          table.push({
            Namespace: nsName.length > 0 ? nsName : null,
            Key: actualkey,
            Value: nsStore.get(actualkey),
            Validity: expiresAt
              ? new Date(expiresAt).toLocaleString()   // local date/time
              : null,
            Expired: isExpired
          });
        }
      });
      if (table.length > 0) {
        console.table(table);
      }
      else {
        console.log('Origin Storage is EMPTY');
      }
      console.groupEnd();
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'navtree_table_format', { // Doxygen NAVTREE Table Format
    get() {
      console.group('● Doxygen NAVTREE');
      console.log(`Displays the default NAVTREE generated by Doxygen in Table Format`);
      displayDefTree(false);
      console.groupEnd();
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'navtree_group_format', { // Doxygen NAVTREE Group Format
    get() {
      console.group('● Doxygen NAVTREE');
      console.log(`Displays the default NAVTREE generated by Doxygen in Group Format`);
      displayDefTree(true);
      console.groupEnd();
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'html_pages_table_format', { // Doxy Plus HTML Pages Table Format
    get() {
      console.group('● Doxy-Plus HTML Pages Tree');
      console.log(`Displays the modified version of default Doxygen NAVTREE generated by Doxy-Plus in table format. The modified NAVTREE has streamlined, flattened entries and includes all HTML pages from the default NAVTREE—it omits duplicate entries and excludes on-page links (e.g., links to functions and variables within a class). On-page links for classes and structs are generated in the Page Links tree, which you can view using ${_consoleObjectName}.page-links_table_format or ${_consoleObjectName}.page-links_group_format.\n\nTo verify that no HTML pages are missing, use ${_consoleObjectName}.missed_html_pages.`);
      if (_htmlpages.length > 0) {
        printTreeTableFormat(_htmlpages);
      }
      else {
        console.log('Doxy-Plus HTML Pages Tree is EMPTY');
      }
      console.groupEnd();
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'html_pages_group_format', { // Doxy Plus HTML Pages Group Format
    get() {
      console.group('● Doxy-Plus HTML Pages Tree');
      console.log(`Displays the modified version of default Doxygen NAVTREE generated by Doxy-Plus in group format. The modified NAVTREE has streamlined, flattened entries and includes all HTML pages from the default NAVTREE—it omits duplicate entries and excludes on-page links (e.g., links to functions and variables within a class). On-page links for classes and structs are generated in the Page Links tree, which you can view using ${_consoleObjectName}.page-links_table_format or ${_consoleObjectName}.page-links_group_format.\n\nTo verify that no HTML pages are missing, use ${_consoleObjectName}.missed_html_pages.`);
      if (_htmlpages.length > 0) {
        printTreeGroupFormat(_htmlpages);
      }
      else {
        console.log('Doxy-Plus HTML Pages Tree is EMPTY');
      }
      console.groupEnd();
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'missed_html_pages', { // Missed HTML Pages
    get() {
      console.group('● Missed HTML Pages');
      console.log(`Displays a list of HTML pages that are present in the default NAVTREE generated by Doxygen but are not present in HTMl-Pages Tree generated by Doxy-Plus.`);
      displayMissedHtmlPages();
      console.groupEnd();
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'page_links_table_format', { // Doxy Plus Page Links Tree Table Format
    get() {
      console.group('● Doxy-Plus Page Links Tree');
      console.log(`Displays the Page Links Tree generated by Doxy-Plus in Table Format. This tree is only generated for HTML pages that contains on-page links.`);
      if (_pageLinks.length > 0) {
        printTreeTableFormat(_pageLinks);
      }
      else {
        console.log(`Doxy-Plus Page Links Tree is EMPTY: ${_pageLinksRemark}`);
      }
      console.groupEnd();
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'page_links_group_format', { // Doxy Plus Page Links Tree Group Format
    get() {
      console.group('● Doxy-Plus Page Links Tree');
      console.log(`Displays the Page Links Tree generated by Doxy-Plus in Group Format. This tree is only generated for HTML pages that contains on-page links.`);
      if (_pageLinks.length > 0) {
        printTreeGroupFormat(_pageLinks);
      }
      else {
        console.log(`Doxy-Plus Page Links Tree is EMPTY: ${_pageLinksRemark}`);
      }
      console.groupEnd();
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'page_link_remarks', { // Doxy Plus Page Links Tree Remarks
    get() {
      console.log(`Doxy Plus Page Links Tree Remarks: ${_pageLinksRemark}`);
    },
    configurable: true
  });

  Object.defineProperty(consoleObject, 'info', { // Info
    // Defines a info property that can be called in browser console
    get() {
      console.group('● Doxy Plus Debug Information:');

      console.log(`● ${_consoleObjectName}.info\n\nThis information ouput`);

      console.log(`● ${_consoleObjectName}.last_update\n\nThe Date-Time of the current update.`);

      console.log(`● ${_consoleObjectName}.project_root\n\nProject root location: If the project is hosted on GitHub, the root is the origin URL plus the repository name; otherwise, it defaults to the local folder path on disk.`);

      console.log(`● ${_consoleObjectName}.project_namespace\n\nProject Namespace: This namespace is used by Doxy-Plus to store project data. Doxy-Plus uses store.js's (https://github.com/marcuswestin/store.js) namespace feature. Assigning each project its own namespace ensures that data remains isolated and cannot conflict with other projects.\n\nBy default, store.js uses the browser's localStorage, which namespaces data by origin. As a result, projects sharing the same origin (e.g. some.com/proj_a and some.com/proj_b) will share the same storage. Likewise, projects loaded from different disk locations (e.g. D:/file/proj_a and E:/other/proj_b) also end up using the same localStorage.`);

      console.log(`● ${_consoleObjectName}.storage_clear_all\n\nClears all storage for this origin. Removes any data stored by projects under this origin—for example, both some.com/proj_a and some.com/proj_b share the same origin, or local files D:/file/proj_a and E:/other/proj_b share the same origin, and both would have their data cleared.`)

      console.log(`● ${_consoleObjectName}.storage_local\n\nDisplays the current contents of the browser's localStorage, including default entries and data from all projects. The browser's localStorage persists on disk indefinitely until explicitly cleared.\n\nProject data saved by Doxy-Plus includes an expiration (using store.js: https://github.com/marcuswestin/store.js) and will be removed the next time it's accessed (for example, when opening a project on the same origin). Entries written by store.js use a special signature, so their raw values may appear as “garbage”. To decode them correctly, always read using ${_consoleObjectName}.storage_origin (for all projects) or ${_consoleObjectName}.storage_project (for this project).`);

      console.log(`● ${_consoleObjectName}.storage_session\n\nDisplays the current contents of the browser's sessionStorage. The browser's sessionStorage persists for the lifetime of the tab—surviving reloads—but is cleared when the tab is closed. Doxy-Plus (through store.js: https://github.com/marcuswestin/store.js) uses it as a fallback storage location. By default there are no data stored by Doxy-Plus in browser's sessionStorage.`);

      console.log(`● ${_consoleObjectName}.storage_project\n\nDisplays the data stored by Doxy-Plus for the current project. Doxy-Plus uses store.js (https://github.com/marcuswestin/store.js) to save project data within a project-specific namespace in browser's localStorage and to enforce an expiry timeout. When a project opens, data from all projects on the same origin—for example, some.com/proj_a and some.com/proj_b, or local files D:/file/proj_a and E:/other/proj_b—is checked for expiry, and any expired entries are removed.`);

      console.log(`● ${_consoleObjectName}.storage_origin\n\nDisplays the data stored by Doxy-Plus for all projects at the current origin. Projects share the same origin, for example, some.com/proj_a and some.com/proj_b share the same origin, or local files D:/file/proj_a and E:/other/proj_b share the same origin of being local. Doxy-Plus uses store.js (https://github.com/marcuswestin/store.js) to save project data within a project-specific namespace in browser's localStorage and to enforce an expiry timeout. When a project opens, data from all projects on the same origin is checked for expiry, and any expired entries are removed.`);

      console.log(`● ${_consoleObjectName}.navtree_table_format\n\nDisplays the default NAVTREE generated by Doxygen in Table Format`);

      console.log(`● ${_consoleObjectName}.navtree_group_format\n\nDisplays the default NAVTREE generated by Doxygen in Group Format`);

      console.log(`● ${_consoleObjectName}.html_pages_table_format\n\nDisplays the modified version of default Doxygen NAVTREE generated by Doxy-Plus in table format. The modified NAVTREE has streamlined, flattened entries and includes all HTML pages from the default NAVTREE—it omits duplicate entries and excludes on-page links (e.g., links to functions and variables within a class). On-page links for classes and structs are generated in the Page Links tree, which you can view using ${_consoleObjectName}.page-links_table_format or ${_consoleObjectName}.page-links_group_format.\n\nTo verify that no HTML pages are missing, use ${_consoleObjectName}.missed_html_pages.`);

      console.log(`● ${_consoleObjectName}.html_pages_group_format\n\nDisplays the modified version of default Doxygen NAVTREE generated by Doxy-Plus in group format. The modified NAVTREE has streamlined, flattened entries and includes all HTML pages from the default NAVTREE—it omits duplicate entries and excludes on-page links (e.g., links to functions and variables within a class). On-page links for classes and structs are generated in the Page Links tree, which you can view using ${_consoleObjectName}.page-links_table_format or ${_consoleObjectName}.page-links_group_format.\n\nTo verify that no HTML pages are missing, use ${_consoleObjectName}.missed_html_pages.`);

      console.log(`● ${_consoleObjectName}.missed_html_pages\n\nDisplays a list of HTML pages that are present in the default NAVTREE generated by Doxygen but are not present in HTMl-Pages Tree generated by Doxy-Plus.`);

      console.log(`● ${_consoleObjectName}.page_links_table_format\n\nDisplays the Page Links Tree generated by Doxy-Plus in Table Format. This tree is only generated for HTML pages that contains on-page links.`);

      console.log(`● ${_consoleObjectName}.page_links_group_format\n\nDisplays the Page Links Tree generated by Doxy-Plus in Group Format. This tree is only generated for HTML pages that contains on-page links.`);

      console.log(`● ${_consoleObjectName}.page_links_remarks\n\n Remarks made by Doxy-Plus for Page Links tree generation.`);
      console.groupEnd();
    },
    configurable: true
  });

  // Assign "dp" as the object for window so that it can be used as debug handler in console,
  // if "dp" is not available then we use "debugDoxyPlus". This can be used in browser console
  // to call the above attached properties.
  // window.dp = Object.create(null); // if set below else will be executed, this is just to
  if (window.dp !== undefined) {
    console.log('● Full Reload: "dp" already defined - "debugDoxyPlus" is the console debug handler');
    window.debugDoxyPlus = consoleObject;
    _consoleObjectName = 'debugDoxyPlus';
  }
  else {
    console.log('● Full Reload: "dp" is the console debug handler');
    window.dp = consoleObject;
    _consoleObjectName = 'dp';
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 CONSOLE OBJECT

  // #region 🟩 DOCUMENT LOADING CALLS
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  async function docOnReady() {
    // Runs when the DOM is available, much earlier than window.addEventListener('load').
    // Maintain this sequence of calls; order is crucial for correct behavior.
    searchbarTweak();               // Sets search selector text instead of a magnifying-glass icon.
    optionsInit();                  // Adds the options button and options window
    dualNavInit();                  // Initializes dual nav panes and attaches the resize handler.
    await genHtmlPages();           // Generates the primary tree from the default Doxygen NAVTREE.
    checkReload();                  // Redirects the URL if necessary; primary tree must be ready first.
    await genPageLinks();           // Generates the secondary tree for class or struct pages.
    setupResizeObservers();         // Observes element size changes per values in doxy-plus.css.
    searchResultWindowObserver();   // Matches search-result window’s position/width to the search bar.
    buildTrees();                   // Builds the display trees for primary and secondary panes.
    purgeExpiredData();             // Removes any expired stored data for this origin.
  }

  // Fires as soon as the browser has parsed the HTML and built the DOM (Document Object Model) tree — before images, 
  // stylesheets, iframes, etc., have all finished loading.
  // ⚠️ Fires much earlier than 'window.addEventListener('load', function ()...'
  // ⚠️ Guranteed that 'docOnReady()' will fire once DOM has been prased and is available 
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', docOnReady);
  } else {
    docOnReady();
  }

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 DOCUMENT LOADING CALLS

  // #region 🟩 WINDOW ON LOAD CALL
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  /*
  window.addEventListener('load', function () {
    // Fires after the entire page is “loaded” — HTML parsed and all external resources (images, styles, frames, fonts,
    // scripts, etc.) have finished downloading.
    // ⚠️ Always happens later than DOMContentLoaded.
  });
  */

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // #endregion 🟥 WINDOW ON LOAD CALL

})(jQuery);